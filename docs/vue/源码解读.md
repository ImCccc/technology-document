# vue2 源码解读

<https://vue-js.com/learn-vue/reactive/object.html#_4-%E4%BE%9D%E8%B5%96%E5%88%B0%E5%BA%95%E6%98%AF%E8%B0%81>

**v2 存在的问题:**

1. 数据量大后带来的渲染和更新的性能问题
2. 源码自身的维护性
3. 想舍弃但为了兼容而一直保留的鸡肋 api
4. 编程体验差, 逻辑复用差

**v3 做了哪些优化?**

1. 源码优化

   > v3 使用 `monorepo` 管理源码, 让代码更加易于维护和开发
   >
   > 相对于 v2 的源码组织方式, monorepo 将模块拆分到不同的 package 中,每一个 package 都有自己的 API,类型定义和测试, 主要使得模块拆分的更细化,职责划分的更加明确,模块之间的依赖也更加明确,开发人员也更好阅读,更好修改维护;
   >
   > 另外 package 是可以独立于 vue.js 使用的, 这样用户就可以只使用某一个功能,而不需要依赖整个 vue.js, v2 是做不到这一点

2. 使用 `typescript` 开发源码

   > Flow 是 Fackbook 出品的静态类型检查工具, v2 是使用 Flow 做类型检查, 对于一些复杂的场景支持并不好,
   >
   > v3 使用 `typescript`

3. 源码体积优化

   > v3 移除了冷门的 api, 引入 tree-shaking; `tree-shaking` 依赖 es2015 的模块语法, 即 `import` 和 `export`, 通过编辑阶段的静态分析, 找到没有引入的模块并打上标记, 达到减少体积的优化

4. 数据劫持优化

   > v2 使用 `Object.defineProperty` 这个 api 劫持数据的 `getter` `setter`, 但是存在一些问题, 例如不能知道对象的某一个属性被删除和增加, 虽然添加了 `$set` 和 `$delete` 的实例方法, 但是对于用户来说,还是添加了一定的心智负担; 还有对于深层次嵌套的对象, 必须递归将所有属性变为响应式, 会有性能问题;
   >
   > v3 使用 Proxy API 做数据劫持, 它劫持的是整个对象, 对于对象的增加和删除都能监测到,<font color="red">但是 Proxy 不能内部深层次的数据变化,</font> v3 的处理方式是在 getter 中去递归响应式, 这样的好处是真正访问到内部对象, 才会变成响应式,而不是无脑的递归, 提高了性能

5. 编辑优化

   > v2 的数据更新触发重新渲染的粒度是组件级别的, 虽然能保证组件更新的最少化, 但是在更新过程中需要遍历整个 vNode 树, 当组件只有少量的动态节点更新, 很多遍历都是性能的浪费;
   >
   > v3 通过编译阶段对静态模板的分析, 将静态节点标记, vnode 更新由之前的与 “模板大小” 相关提升为与 “动态内容数量” 相关

6. 语法优化
   > v2 使用 Options API 的规范开发, 缺点就是对于复杂的逻辑, 开发过程中需要跳来跳去, 修改起来容易出错;
   >
   > v3 提供了 Composition API, 将某一个逻辑相关的逻辑封装在一个函数中, 当修改一个功能, 就不会出现上述的问题;
   >
   > v2 的逻辑复用是使用 mixins, 会有命名冲突, 数据来源不清晰等问题;
   >
   > v3 的 Composition 就很好解决这样的问题, 而且有更好的类型支持, 对 tree-shaking 也更好的支持

## Object 变得可观测

原理就是递归对象的每一个属性, 通过 Object.defineProperty 方法对对象的每一个属性进行配置, 通过劫持 get 和 set 方法, 可以知道对象什么时候被修改, 什么时候被读取, <font color="red">然后在获取数据时收集依赖，数据变化时通知依赖更新。</font> 具体代码:

```javascript
class Observer {
  constructor(value) {
    this.value = value;
    if (Array.isArray(value)) {
      // value 是数组的逻辑 ......
    } else {
      this.walk(value);
    }
  }

  walk(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i]);
    }
  }
}

function defineReactive(obj, key, val) {
  if (arguments.length === 2) {
    val = obj[key];
  }

  if (typeof val === "Object") {
    new Observer(val);
  }

  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get() {
      console.log(`${key}属性被读取了`);
      return val;
    },
    set(newVal) {
      if (newVal === val) return;
      console.log(`${key}属性被修改了`);
      val = newVal;
    },
  });
}

// 那么现在，我们就可以这样定义car, 这样，car的两个属性都变得可观测了。
let car = new Observer({
  brand: "BMW",
  price: 3000,
});
```

### 什么是依赖收集

上一节, 我们就能知道数据什么时候发生了变化，那么当数据发生变化时，我们去通知视图更新就好了。视图里谁用到了这个数据就更新谁;

给每个数据都建一个依赖数组，谁依赖了这个数据就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，就去它对应的依赖数组中，把每个依赖都通知一遍。这个过程就是依赖收集。

在 getter 中收集依赖，在 setter 中通知依赖更新

### 依赖管理器 Dep 类

上述所说的依赖收集和更新, 都在一个依赖管理器中进行, 依赖管理器就是 Dep ，代码如下

```javascript
// 源码位置：src/core/observer/dep.js
import { remove } from "../util/index";
import type Watcher from "./watcher";

let uid = 0;
export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array<Watcher>;

  constructor() {
    this.id = uid++;
    this.subs = [];
  }

  addSub(sub: Watcher) {
    this.subs.push(sub);
  }

  removeSub(sub: Watcher) {
    remove(this.subs, sub);
  }

  depend() {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  }

  notify() {
    const subs = this.subs.slice();
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  }
}

Dep.target = null;
const targetStack = [];

export function pushTarget(target: ?Watcher) {
  targetStack.push(target);
  Dep.target = target;
}

export function popTarget() {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}
```

### 依赖 Watcher 类

Vue 中还实现了一个叫做 Watcher 的类，而 Watcher 类的实例就是我们上面所说的那个依赖。谁用到了数据，谁就是依赖，我们就为谁创建一个 Watcher 实例。在之后数据变化时，我们不直接去通知依赖更新，而是通知 Watch 实例，由 Watcher 实例去通知真正的视图。精简过的源码如下:

```javascript
import { _Set as Set, isObject, parsePath, remove } from "../util/index";
import Dep, { pushTarget } from "./dep";
import { queueWatcher } from "./scheduler";
import type { SimpleSet } from "../util/index";
let uid = 0;

export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deep: boolean;
  user: boolean;
  lazy: boolean;
  sync: boolean;
  dirty: boolean;
  active: boolean;
  deps: Array<Dep>;
  newDeps: Array<Dep>;
  depIds: SimpleSet;
  newDepIds: SimpleSet;
  before: ?Function;
  getter: Function;
  value: any;

  constructor(
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm;
    if (isRenderWatcher) vm._watcher = this;
    vm._watchers.push(this);

    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
      this.before = options.before;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid;
    this.active = true;
    this.dirty = this.lazy;
    this.deps = [];
    this.newDeps = [];
    this.depIds = new Set();
    this.newDepIds = new Set();
    this.expression = "";

    /*
     * data = { a: { b: { c: 2 } } }
     * parsePath('a.b.c')(data)  // 2
     */
    this.getter = parsePath(expOrFn);
    this.value = this.get();
  }

  /**
   * 重新收集依赖关系
   */
  get() {
    /*
      Dep.target = null;
      const targetStack = [];
      function pushTarget(target) {
        targetStack.push(target);
        Dep.target = target;
      }
    */
    pushTarget(this);
    const vm = this.vm;
    // 因为之前已经将数据变得可监测, 所以可以在获取数据的时候, 收集当前的依赖
    return this.getter.call(vm, vm);
  }

  addDep(dep: Dep) {
    const id = dep.id;
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  }

  cleanupDeps() {
    let i = this.deps.length;
    while (i--) {
      const dep = this.deps[i];
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }
    let tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  }

  update() {
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  }

  run() {
    const value = this.get();
    const oldValue = this.value;
    this.value = value;
    this.cb.call(this.vm, value, oldValue);
  }

  evaluate() {
    this.value = this.get();
    this.dirty = false;
  }

  depend() {
    let i = this.deps.length;
    while (i--) {
      this.deps[i].depend();
    }
  }

  teardown() {
    if (this.active) {
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this);
      }
      let i = this.deps.length;
      while (i--) {
        this.deps[i].removeSub(this);
      }
      this.active = false;
    }
  }
}
```

Watcher 类的代码实现逻辑：

1. 当实例化 Watcher 类时，会先执行其构造函数
2. 在构造函数中调用了 `this.get()`实例方法；
3. `get()`方法调用 `pushTarget` 将实例付给 `Dep.target`；通过 `this.getter.call(vm, vm)` 获取一下被依赖的数据，获取被依赖数据的目的是触发该数据上面的 `getter`, 在 `getter` 里会调用 `dep.depend()`收集依赖。
4. 当数据变化时，会触发数据的 `setter` ，在 `setter` 中调用了`dep.notify()`方法，在`dep.notify()`方法中，遍历所有 `watcher` 实例，执行依赖的`update()`方法，在`update()`方法中调用数据变化的更新回调函数，从而更新视图

### 不足之处

`Object.defineProperty` 只能观测到 object 数据的取值及设置值，当我们向 `object` 数据里添加一对新的 `key/value` 或删除一对已有的 `key/value` 时，它是无法观测到的，导致对 `object` 数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。

为了解决这一问题，Vue 增加了两个全局 API: `Vue.set ` `Vue.delete`

## Array 变得可观测

`Object.defineProperty` 是对象原型上的, Array 无法使用, 需要对 Array 型数据设计一套另外的变化侦测机制。
<font color="red">原理还是在获取数据时收集依赖，数据变化时通知依赖更新。</font>

- 收集依赖

  > arr 这个数据始终都存在于一个 object 数据对象中，要用到 arr 这个数据，得先从 object 数据对象中获取一下 arr 数据，而从 object 数据对象中获取 arr 数据自然就会触发 arr 的 getter，所以我们就可以在 getter 中收集依赖。

- 通知更新

  > 通过拦截能让数组发生变化的方法 : `push` `pop` `shift` `unshift` `splice` `sort` `reverse`, 实现数据更新通知视图更新

- 源码

```javascript
const arrayProto = Array.prototype;
const arrayMethods = Object.create(arrayProto);

function def(obj: Object, key: string, val: any, enumerable?: boolean) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true,
  });
}

const methodsToPatch = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse",
];

methodsToPatch.forEach(function (method) {
  const original = arrayProto[method];
  def(arrayMethods, method, function mutator(...args) {
    const result = original.apply(this, args);
    const ob = this.__ob__;
    let inserted;
    switch (method) {
      case "push":
      case "unshift":
        inserted = args;
        break;
      case "splice":
        inserted = args.slice(2);
        break;
    }
    if (inserted) ob.observeArray(inserted);
    // notify change
    ob.dep.notify();
    return result;
  });
});
```

```javascript
export class Observer {
  value: any;
  dep: Dep;
  constructor(value: any) {
    if (Array.isArray(value)) {
      value.__proto__ = arrayMethods;
      this.observeArray(value);
    } else {
      //...
    }
  }
  observeArray(items: Array<any>) {
    // ...
  }
}
```

## VNode

```javascript
export default class VNode {
  tag: string | void;
  data: VNodeData | void;
  children: ?Array<VNode>;
  text: string | void;
  elm: Node | void;
  ns: string | void;
  context: Component | void; // rendered in this component's scope
  key: string | number | void;
  componentOptions: VNodeComponentOptions | void;
  componentInstance: Component | void; // component instance
  parent: VNode | void; // component placeholder node

  // strictly internal
  raw: boolean; // contains raw HTML? (server only)
  isStatic: boolean; // hoisted static node
  isRootInsert: boolean; // necessary for enter transition check
  isComment: boolean; // empty comment placeholder?
  isCloned: boolean; // is a cloned node?
  isOnce: boolean; // is a v-once node?
  asyncFactory: Function | void; // async component factory function
  asyncMeta: Object | void;
  isAsyncPlaceholder: boolean;
  ssrContext: Object | void;
  fnContext: Component | void; // real context vm for functional nodes
  fnOptions: ?ComponentOptions; // for SSR caching
  devtoolsMeta: ?Object; // used to store functional render context for devtools
  fnScopeId: ?string; // functional scope id support

  constructor(
    tag?: string,
    data?: VNodeData,
    children?: ?Array<VNode>,
    text?: string,
    elm?: Node,
    context?: Component,
    componentOptions?: VNodeComponentOptions,
    asyncFactory?: Function
  ) {
    /*当前节点的标签名*/
    this.tag = tag;

    /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/
    this.data = data;

    /*当前节点的子节点，是一个数组*/
    this.children = children;

    /*当前节点的文本*/
    this.text = text;

    /*当前虚拟节点对应的真实dom节点*/
    this.elm = elm;

    this.ns = undefined;

    /*当前组件节点对应的Vue实例*/
    this.context = context;

    /*函数式组件对应的Vue实例*/
    this.fnContext = undefined;
    // 函数式组件的option选项
    this.fnOptions = undefined;
    this.fnScopeId = undefined;

    this.key = data && data.key;

    /*组件的option选项*/
    this.componentOptions = componentOptions;
    /*当前节点对应的组件的实例*/
    this.componentInstance = undefined;

    /*当前节点的父节点*/
    this.parent = undefined;

    /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/
    this.raw = false;

    /*静态节点标志*/
    this.isStatic = false;

    /*是否作为跟节点插入*/
    this.isRootInsert = true;

    /*是否为注释节点*/
    this.isComment = false;

    /*是否为克隆节点*/
    this.isCloned = false;

    this.isOnce = false;
    this.asyncFactory = asyncFactory;
    this.asyncMeta = undefined;
    this.isAsyncPlaceholder = false;
  }

  get child(): Component | void {
    return this.componentInstance;
  }
}
```

**VNode 的类型**

- 注释节点
- 文本节点
- 元素节点
- 组件节点
- 函数式组件节点
- 克隆节点

1. 注释节点

```javascript
export const createEmptyVNode = (text: string = "") => {
  const node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};
```

注释节点只需两个属性，分别是：text 和 isComment。其中 text 属性表示具体的注释信息，isComment 是一个标志，用来标识一个节点是否是注释节点。

2. 文本节点

```javascript
export function createTextVNode(val: string | number) {
  return new VNode(undefined, undefined, undefined, String(val));
}
```

文本节点只需要一个 text 属性用来表示具体的文本信息

3. 克隆节点

```javascript
export function cloneVNode(vnode: VNode): VNode {
  const cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children && vnode.children.slice(),
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned;
}
```

克隆节点就是把已有节点的属性全部复制到新节点中，而现有节点和新克隆得到的节点之间唯一的不同就是克隆得到的节点 isCloned 为 true

**VNode 的作用**

我们在视图渲染之前，把写好的 template 模板先编译成 VNode 并缓存下来，等到数据发生变化页面需要重新渲染的时候，我们把数据发生变化后生成的 VNode 与前一次缓存下来的 VNode 进行对比，找出差异，然后有差异的 VNode 对应的真实 DOM 节点就是需要重新渲染的节点，最后根据有差异的 VNode 创建出真实的 DOM 节点再插入到视图中，最终完成一次视图更新。

**总结**

VNode 以 JS 的计算性能来换取操作真实 DOM 所消耗的性能。Vue 中是通过 VNode 类来实例化出不同类型的虚拟 DOM 节点，不同类型节点生成的属性的不同，所谓不同类型的节点其本质还是一样的，都是 VNode 类的实例，只是在实例化时传入的属性参数不同罢了。最后探究了 VNode 的作用，有了数据变化前后的 VNode，我们才能进行后续的 DOM-Diff 找出差异，最终做到只更新有差异的视图，从而达到尽可能少的操作真实 DOM 的目的，以节省性能。
