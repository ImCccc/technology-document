# 源码解读

**v2 存在的问题:**

1. 数据量大后带来的渲染和更新的性能问题
2. 源码自身的维护性
3. 想舍弃但为了兼容而一直保留的鸡肋 api
4. 编程体验差, 逻辑复用差

**v3 做了哪些优化?**

1. 源码优化

   > v3 使用 `monorepo` 管理源码, 让代码更加易于维护和开发
   >
   > 相对于 v2 的源码组织方式, monorepo 将模块拆分到不同的 package 中,每一个 package 都有自己的 API,类型定义和测试, 主要使得模块拆分的更细化,职责划分的更加明确,模块之间的依赖也更加明确,开发人员也更好阅读,更好修改维护;
   >
   > 另外 package 是可以独立于 vue.js 使用的, 这样用户就可以只使用某一个功能,而不需要依赖整个 vue.js, v2 是做不到这一点

2. 使用 `typescript` 开发源码

   > Flow 是 Fackbook 出品的静态类型检查工具, v2 是使用 Flow 做类型检查, 对于一些复杂的场景支持并不好,
   >
   > v3 使用 `typescript`

3. 源码体积优化

   > v3 移除了冷门的 api, 引入 tree-shaking; `tree-shaking` 依赖 es2015 的模块语法, 即 `import` 和 `export`, 通过编辑阶段的静态分析, 找到没有引入的模块并打上标记, 达到减少体积的优化

4. 数据劫持优化

   > v2 使用 `Object.defineProperty` 这个 api 劫持数据的 `getter` `setter`, 但是存在一些问题, 例如不能知道对象的某一个属性被删除和增加, 虽然添加了 `$set` 和 `$delete` 的实例方法, 但是对于用户来说,还是添加了一定的心智负担; 还有对于深层次嵌套的对象, 必须递归将所有属性变为响应式, 会有性能问题;
   >
   > v3 使用 Proxy API 做数据劫持, 它劫持的是整个对象, 对于对象的增加和删除都能监测到,<font color="red">但是 Proxy 不能内部深层次的数据变化,</font> v3 的处理方式是在 getter 中去递归响应式, 这样的好处是真正访问到内部对象, 才会变成响应式,而不是无脑的递归, 提高了性能

5. 编辑优化

   > v2 的数据更新触发重新渲染的粒度是组件级别的, 虽然能保证组件更新的最少化, 但是在更新过程中需要遍历整个 vNode 树, 当组件只有少量的动态节点更新, 很多遍历都是性能的浪费;
   >
   > v3 通过编译阶段对静态模板的分析, 将静态节点标记, vnode 更新由之前的与 “模板大小” 相关提升为与 “动态内容数量” 相关

6. 语法优化
   > v2 使用 Options API 的规范开发, 缺点就是对于复杂的逻辑, 开发过程中需要跳来跳去, 修改起来容易出错;
   >
   > v3 提供了 Composition API, 将某一个逻辑相关的逻辑封装在一个函数中, 当修改一个功能, 就不会出现上述的问题;
   >
   > v2 的逻辑复用是使用 mixins, 会有命名冲突, 数据来源不清晰等问题;
   >
   > v3 的 Composition 就很好解决这样的问题, 而且有更好的类型支持, 对 tree-shaking 也更好的支持

## vue2 源码解读
