# 源码解读

**v2 存在的问题:**

1. 数据量大后带来的渲染和更新的性能问题
2. 源码自身的维护性
3. 想舍弃但为了兼容而一直保留的鸡肋 api
4. 编程体验差, 逻辑复用差

**v3 做了哪些优化?**

1. 源码优化

   > v3 使用 `monorepo` 管理源码, 让代码更加易于维护和开发
   >
   > 相对于 v2 的源码组织方式, monorepo 将模块拆分到不同的 package 中,每一个 package 都有自己的 API,类型定义和测试, 主要使得模块拆分的更细化,职责划分的更加明确,模块之间的依赖也更加明确,开发人员也更好阅读,更好修改维护;
   >
   > 另外 package 是可以独立于 vue.js 使用的, 这样用户就可以只使用某一个功能,而不需要依赖整个 vue.js, v2 是做不到这一点

2. 使用 `typescript` 开发源码

   > Flow 是 Fackbook 出品的静态类型检查工具, v2 是使用 Flow 做类型检查, 对于一些复杂的场景支持并不好,
   >
   > v3 使用 `typescript`

3. 源码体积优化

   > v3 移除了冷门的 api, 引入 tree-shaking; `tree-shaking` 依赖 es2015 的模块语法, 即 `import` 和 `export`, 通过编辑阶段的静态分析, 找到没有引入的模块并打上标记, 达到减少体积的优化

4. 数据劫持优化

   > v2 使用 `Object.defineProperty` 这个 api 劫持数据的 `getter` `setter`, 但是存在一些问题, 例如不能知道对象的某一个属性被删除和增加, 虽然添加了 `$set` 和 `$delete` 的实例方法, 但是对于用户来说,还是添加了一定的心智负担; 还有对于深层次嵌套的对象, 必须递归将所有属性变为响应式, 会有性能问题;
   >
   > v3 使用 Proxy API 做数据劫持, 它劫持的是整个对象, 对于对象的增加和删除都能监测到,<font color="red">但是 Proxy 不能内部深层次的数据变化,</font> v3 的处理方式是在 getter 中去递归响应式, 这样的好处是真正访问到内部对象, 才会变成响应式,而不是无脑的递归, 提高了性能

5. 编辑优化

   > v2 的数据更新触发重新渲染的粒度是组件级别的, 虽然能保证组件更新的最少化, 但是在更新过程中需要遍历整个 vNode 树, 当组件只有少量的动态节点更新, 很多遍历都是性能的浪费;
   >
   > v3 通过编译阶段对静态模板的分析, 将静态节点标记, vnode 更新由之前的与 “模板大小” 相关提升为与 “动态内容数量” 相关

6. 语法优化
   > v2 使用 Options API 的规范开发, 缺点就是对于复杂的逻辑, 开发过程中需要跳来跳去, 修改起来容易出错;
   >
   > v3 提供了 Composition API, 将某一个逻辑相关的逻辑封装在一个函数中, 当修改一个功能, 就不会出现上述的问题;
   >
   > v2 的逻辑复用是使用 mixins, 会有命名冲突, 数据来源不清晰等问题;
   >
   > v3 的 Composition 就很好解决这样的问题, 而且有更好的类型支持, 对 tree-shaking 也更好的支持

## vue2 源码解读

### Object 变得可观测

原理就是递归对象的每一个属性, 通过 Object.defineProperty 方法对对象的每一个属性进行配置, 通过劫持 get 和 set 方法, 可以知道对象什么时候被修改, 什么时候被读取, 具体代码:

```javascript
class Observer {
  constructor(value) {
    this.value = value;
    if (Array.isArray(value)) {
      // value 是数组的逻辑 ......
    } else {
      this.walk(value);
    }
  }

  walk(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i]);
    }
  }
}

function defineReactive(obj, key, val) {
  if (arguments.length === 2) {
    val = obj[key];
  }

  if (typeof val === "Object") {
    new Observer(val);
  }

  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get() {
      console.log(`${key}属性被读取了`);
      return val;
    },
    set(newVal) {
      if (newVal === val) return;
      console.log(`${key}属性被修改了`);
      val = newVal;
    },
  });
}

// 那么现在，我们就可以这样定义car, 这样，car的两个属性都变得可观测了。
let car = new Observer({
  brand: "BMW",
  price: 3000,
});
```

## 依赖收集

"谁用到了这个数据" 称为 "谁依赖了这个数据", 我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们："你们依赖的数据变啦，你们该更新啦！"。这个过程就是依赖收集。

总结:

- 在 getter 中收集依赖，在 setter 中通知依赖更新。
- Observer 对象中 new 一个依赖管理器 Dep 对象,用于管理依赖更新和收集
